

    /**
     * Display AHP recommendation page
     */


    private $criteria = [
        'age' => 'Age',
        'expected_salary' => 'Expected Salary',
        'distance' => 'Distance',
        'education' => 'Education',
        'experience_duration' => 'Experience',
        'language' => 'Language',
        'organization' => 'Organization',
        'training' => 'Training',
    ];


    public function index_ahp()
    {
        // Retrieve all recruitment applicants and pluck their unique recruitment_demand_ids  
        $recruitmentDemandIds = recruitment_applicant::pluck('recruitment_demand_id')->unique();

        // Filter recruitment_demand based on the unique recruitment_demand_ids  
        $demands =  recruitment_demand::with(['departmentRelation', 'positionRelation'])->whereIn('id', $recruitmentDemandIds)
            ->where('status_demand', 'Approved')
            ->whereColumn('qty_needed', '>', 'qty_fullfil')
            ->get();



        // Return the filtered recruitment_demand data to the view  
        return view('recruitment/ahp_recruitment/index', [
            'demands' => $demands,
            'criteria' => $this->criteria
        ]);
    }

    public function ahp_schedule_interview(Request $request, $id)
    {
        $request->validate([
            'interview_date' => 'required|date',
            'interview_note' => 'required|string',
        ]);

        $applicant = recruitment_applicant::findOrFail($id);

        // Store old interview date to check if this is the first interview
        $oldInterviewDate = $applicant->interview_date;

        $applicant->update([
            'interview_date' => $request->interview_date,
            'interview_note' => str_replace("\r\n", "\n", $request->interview_note),
            'updated_at' => now(),
        ]);

        // Jika sebelumnya NULL, berarti panggilan pertama
        if (is_null($oldInterviewDate)) {
            Mail::to($applicant->email)->send(new InterviewScheduledMail($applicant));
        }

        return response()->json(['message' => 'Interview scheduled successfully']);
    }


    public function calculate(Request $request)




    private function calculateExperienceDurationScore($applicantId, $config = null)
    {
        // Remove debugging statement
        // dd($request->all());
        // Ensure the applicantId is valid
        if (empty($applicantId) || !is_numeric($applicantId)) {
            return 0;
        }

        try {
            // Validate the request - basic validation first
            $validationRules = [
                'demandId' => 'required',
        $experiences = recruitment_applicant_work_experience::where('applicant_id', $applicantId)->get();

        if ($experiences->isEmpty()) {
            return 0; // Default low score for no experience
        }

        $totalDuration = 0;
        $count = $experiences->count();

        foreach ($experiences as $exp) {
            if (empty($exp->working_start)) {
                continue; // Skip invalid entries
            }

            try {
                $startDate = Carbon::parse($exp->working_start);
                $endDate = $exp->working_end ? Carbon::parse($exp->working_end) : Carbon::now();
                $totalDuration += $startDate->diffInYears($endDate);
            } catch (\Exception $e) {
                // Skip this entry if date parsing fails
                continue;
            }
        }

        // Default configuration if none provided
        if (empty($config)) {
            $periodRanges = [
                ['min' => 5, 'max' => 8, 'rank' => 1],
                ['min' => 3, 'max' => 5, 'rank' => 2],
                ['min' => 1, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];

            // Only validate criteria that are included in the request
            $totalPercentage = 0;
            $criteriaKeys = [
                'age',
                'expected_salary',
                'distance',
                'education',
                'experience_duration',
                'organization',
                'language',
                'training'
            $amountRanges = [
                ['min' => 6, 'max' => 7, 'rank' => 1],
                ['min' => 4, 'max' => 5, 'rank' => 2],
                ['min' => 2, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];

            foreach ($criteriaKeys as $key) {
                if ($request->has($key)) {
                    $validationRules[$key] = 'required|numeric|min:0|max:100';
                    $totalPercentage += (float)$request->$key;
                }
            }
            $periodScore = $this->getScoreFromRanges($totalDuration, $periodRanges);
            $amountScore = $this->getScoreFromRanges($count, $amountRanges);

            $request->validate($validationRules);
            return ($periodScore * 0.7) + ($amountScore * 0.3);
        }

            // Validate that percentages sum to 100%
            if (abs($totalPercentage - 100) > 0.01) { // Allow small floating point error
                return response()->json([
                    'success' => false,
                    'message' => 'Total persentase harus 100%'
                ], 422);
            }
        // Use provided configuration
        $periodScore = isset($config['period']) ? $this->getScoreFromRanges($totalDuration, $config['period']) : 0;
        $amountScore = isset($config['amount']) ? $this->getScoreFromRanges($count, $config['amount']) : 0;

            // Get configurations from request
            $criteriaConfigs = $request->criteria_configs ?? [];
        $periodWeight = isset($config['weights']['period']) ? ($config['weights']['period'] / 100) : 0.7;
        $amountWeight = isset($config['weights']['amount']) ? ($config['weights']['amount'] / 100) : 0.3;

            // Convert percentages to weights (0-1 scale)
            $weights = [];
            foreach ($criteriaKeys as $key) {
                if ($request->has($key)) {
                    $weights[$key] = $request->$key / 100;
        return ($periodScore * $periodWeight) + ($amountScore * $amountWeight);
    }

    private function calculateTrainingScore($applicantId, $config = null)
    {
        // Ensure the applicantId is valid
        if (empty($applicantId) || !is_numeric($applicantId)) {
            return 0;
        }

        $trainings = recruitment_applicant_training::where('applicant_id', $applicantId)->get();

        if ($trainings->isEmpty()) {
            return 0;
        }

        $count = $trainings->count();
        $totalDuration = 0;

        foreach ($trainings as $training) {
            if ($training->start_date && $training->end_date) {
                try {
                    $startDate = Carbon::parse($training->start_date);
                    $endDate = Carbon::parse($training->end_date);
                    $totalDuration += $startDate->diffInMonths($endDate);
                } catch (\Exception $e) {
                    // Skip this entry if date parsing fails
                    continue;
                }
            }
        }

            // Get applicants data
            $demand = recruitment_demand::findOrFail($request->demandId);
            $applicants = recruitment_applicant::where('recruitment_demand_id', $demand->id)
                ->where('status_applicant', 'Pending')
                ->whereNull('interview_date')->get();
        // Convert duration to years for scoring
        $durationInYears = $totalDuration / 12;

            if ($applicants->isEmpty()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Tidak ada pelamar untuk demand ini'
                ], 200);
            }
        // Default configuration if none provided
        if (empty($config)) {
            $periodRanges = [
                ['min' => 5.1, 'max' => 8, 'rank' => 1],
                ['min' => 3.1, 'max' => 5, 'rank' => 2],
                ['min' => 1.1, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];

            $rankings = $this->calculateApplicantScores($applicants, $weights, $criteriaConfigs);
            $amountRanges = [
                ['min' => 6, 'max' => 7, 'rank' => 1],
                ['min' => 4, 'max' => 5, 'rank' => 2],
                ['min' => 2, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];

            return response()->json([
                'success' => true,
                'rankings' => $rankings
            ], 200);
        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Data yang dikirim tidak valid',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error: ' . $e->getMessage()
            ], 500);
            $periodScore = $this->getScoreFromRanges($durationInYears, $periodRanges);
            $amountScore = $this->getScoreFromRanges($count, $amountRanges);

            return ($periodScore * 0.7) + ($amountScore * 0.3);
        }

        // Use provided configuration
        $periodScore = isset($config['period']) ? $this->getScoreFromRanges($durationInYears, $config['period']) : 0;
        $amountScore = isset($config['amount']) ? $this->getScoreFromRanges($count, $config['amount']) : 0;

        $periodWeight = isset($config['weights']['period']) ? ($config['weights']['period'] / 100) : 0.7;
        $amountWeight = isset($config['weights']['amount']) ? ($config['weights']['amount'] / 100) : 0.3;

        return ($periodScore * $periodWeight) + ($amountScore * $amountWeight);
    }

    private function calculateApplicantScores($applicants, $weights, $criteriaConfigs)
    private function calculateOrganizationScore($applicantId, $config = null)
    {
        $scores = [];
        // Ensure the applicantId is valid
        if (empty($applicantId) || !is_numeric($applicantId)) {
            return 0;
        }

        foreach ($applicants as $applicant) {
            $criteriaScores = [];
        $organizations = recruitment_applicant_organization::where('applicant_id', $applicantId)->get();

            // Only calculate scores for criteria that have weights
            foreach ($weights as $criterion => $weight) {
                switch ($criterion) {
                    case 'age':
                        $criteriaScores['age'] = $this->calculateAgeScore(
                            $applicant->birth_date,
                            $criteriaConfigs['age'] ?? null
                        );
                        break;
                    case 'expected_salary':
                        $criteriaScores['expected_salary'] = $this->calculateExpectedSalaryScore(
                            $applicant->expected_salary ?? 0,
                            $criteriaConfigs['expected_salary'] ?? null
                        );
                        break;
                    case 'distance':
                        $criteriaScores['distance'] = $this->calculateDistanceScore(
                            $applicant->distance ?? 0,
                            $criteriaConfigs['distance'] ?? null
                        );
                        break;
                    case 'education':
                        $education = recruitment_applicant_education::where('applicant_id', $applicant->id)
                            ->orderBy('end_education', 'desc')
                            ->first();
                        $criteriaScores['education'] = $this->calculateEducationScore(
                            $education,
                            $criteriaConfigs['education'] ?? null
                        );
                        break;
                    case 'experience_duration':
                        $criteriaScores['experience_duration'] = $this->calculateExperienceDurationScore(
                            $applicant->id,
                            $criteriaConfigs['experience_duration'] ?? null
                        );
                        break;
                    case 'training':
                        $criteriaScores['training'] = $this->calculateTrainingScore(
                            $applicant->id,
                            $criteriaConfigs['training'] ?? null
                        );
                        break;
                    case 'language':
                        $criteriaScores['language'] = $this->calculateLanguageScore(
                            $applicant->id,
                            $criteriaConfigs['language'] ?? null
                        );
                        break;
                    case 'organization':
                        $criteriaScores['organization'] = $this->calculateOrganizationScore(
                            $applicant->id,
                            $criteriaConfigs['organization'] ?? null
                        );
                        break;
                }
            }
        if ($organizations->isEmpty()) {
            return 0;
        }

            // Calculate weighted sum
            $totalScore = 0;
            foreach ($weights as $criterion => $weight) {
                if (isset($criteriaScores[$criterion])) {
                    $totalScore += $criteriaScores[$criterion] * $weight;
        $count = $organizations->count();
        $totalDuration = 0;

        foreach ($organizations as $org) {
            if ($org->start_date) {
                try {
                    $startDate = Carbon::parse($org->start_date);
                    $endDate = $org->end_date ? Carbon::parse($org->end_date) : Carbon::now();
                    $totalDuration += $startDate->diffInMonths($endDate);
                } catch (\Exception $e) {
                    // Skip this entry if date parsing fails
                    continue;
                }
            }
        }

            $scores[] = [
                'applicant' => $applicant,
                'score' => $totalScore,
                'breakdown' => $criteriaScores
        // Convert duration to years for scoring
        $durationInYears = $totalDuration / 12;

        // Default configuration if none provided
        if (empty($config)) {
            $periodRanges = [
                ['min' => 5.1, 'max' => 8, 'rank' => 1],
                ['min' => 3.1, 'max' => 5, 'rank' => 2],
                ['min' => 1.1, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];

            $amountRanges = [
                ['min' => 6, 'max' => 7, 'rank' => 1],
                ['min' => 4, 'max' => 5, 'rank' => 2],
                ['min' => 2, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];

            $periodScore = $this->getScoreFromRanges($durationInYears, $periodRanges);
            $amountScore = $this->getScoreFromRanges($count, $amountRanges);

            return ($periodScore * 0.4) + ($amountScore * 0.6);
        }

        // Use provided configuration
        $periodScore = isset($config['period']) ? $this->getScoreFromRanges($durationInYears, $config['period']) : 0;
        $amountScore = isset($config['amount']) ? $this->getScoreFromRanges($count, $config['amount']) : 0;

        $periodWeight = isset($config['weights']['period']) ? ($config['weights']['period'] / 100) : 0.4;
        $amountWeight = isset($config['weights']['amount']) ? ($config['weights']['amount'] / 100) : 0.6;

        return ($periodScore * $periodWeight) + ($amountScore * $amountWeight);
    }

    private function calculateLanguageScore($applicantId, $config = null)
    {
        // Ensure the applicantId is valid
        if (empty($applicantId) || !is_numeric($applicantId)) {
            return 0;
        }

        $languages = recruitment_applicant_language::where('applicant_id', $applicantId)->get();

        if ($languages->isEmpty()) {
            return 0; // Default score for no languages
        }

        $verbalWeight = 0.7; // Default 70% weight for verbal skills
        $writtenWeight = 0.3; // Default 30% weight for written skills

        // Override weights if configured
        if ($config && isset($config['weights'])) {
            $verbalWeight = $config['weights']['verbal'] / 100;
            $writtenWeight = $config['weights']['written'] / 100;
        }

        $score = 0;
        $count = 0;

        foreach ($languages as $language) {
            $verbalScore = ($language->verbal === 'Active') ? 1 : 0.5;
            $writtenScore = ($language->written === 'Active') ? 1 : 0.5;

            // Weighted score for this language
            $languageScore = ($verbalScore * $verbalWeight) + ($writtenScore * $writtenWeight);
            $score += $languageScore;
            $count++;
        }

        return collect($scores)->sortByDesc('score')->values();
        // Return average language score
        return $count > 0 ? min(1.0, $score / $count) : 0.2;
    }

    // New helper function to handle range calculations consistently
    private function calculateExpectedSalaryScore($salary, $config = null)
    {
        // Return 0 if salary is empty or invalid
        if (empty($salary) || !is_numeric($salary)) {
            return 0;
        }

        // Convert salary to float to ensure it's numeric
        $salary = (float)$salary;

        // If no config is provided or ranges are empty, use default calculation
        if (empty($config) || empty($config['ranges'])) {
            return match (true) {
                $salary >= 5000001 && $salary <= 8000000 => 1.0,  // Best range
                $salary >= 2000001 && $salary <= 5000000 => 0.8,
                $salary >= 8000001 && $salary <= 10000000 => 0.6,
                $salary >= 0 && $salary <= 2000000 => 0.4,
                $salary >= 10000001 && $salary <= 15000000 => 0.2,
                default => 0
            };
        }

        return $this->getScoreFromRanges($salary, $config['ranges']);
    }

    // Improved getScoreFromRanges function to handle all edge cases
    public function getScoreFromRanges($value, $ranges)
    {
        // Tambahkan debugging untuk tipe data
        //dd(gettype($value), $value, $ranges);
        // If value is not numeric, return 0
        if (!is_numeric($value)) {
            return 0;
        }

        // Convert to float to ensure proper comparison
        $value = (float)$value;

        if (empty($ranges)) {
            return 0;
        }

        // Sort ranges by rank
        $ranges = collect($ranges)->sortBy('rank')->values()->all();
        $totalRanges = count($ranges);

        foreach ($ranges as $range) {
            // Konversi eksplisit ke float jika perlu
            $min = floatval($range['min']);
            $max = floatval($range['max']);
            $value = floatval($value);
            $min = isset($range['min']) ? (float)$range['min'] : 0;
            $max = isset($range['max']) ? (float)$range['max'] : 0;

            // Ensure rank is valid
            $rank = isset($range['rank']) ? (int)$range['rank'] : $totalRanges;

            // Skip invalid ranges
            if (!is_numeric($min) || !is_numeric($max) || !is_numeric($rank)) {
                continue;
            }

            // Untuk semua range, gunakan upper bound inklusif
            if ($value >= $min && $value <= $max) {
                // dd($min, $value, $max, $range['rank'], $totalRanges);
                return 1 - (($range['rank'] - 1) / $totalRanges);
                return 1 - (($rank - 1) / $totalRanges);
            }
        }

        // Value is outside all defined ranges
        return 1 / ($totalRanges + 1);
    }


    // Improved helper functions for all criteria calculations
    private function calculateAgeScore($birthDate, $config = null)
    {
        // Return 0 if birthDate is empty, null, or invalid
        if (empty($birthDate) || !Carbon::hasFormat($birthDate, 'Y-m-d')) {
            return 0;
        }

        $age = Carbon::parse($birthDate)->age;

        // Return 0 if age calculation results in 0 or negative
        if ($age <= 0) {
            return 0;
        }

        // If no config is provided or ranges are empty, use default calculation
        if (empty($config) || empty($config['ranges'])) {
            return match (true) {
                $age <= 17 => 1.0,  // Very young, highest score
                $age <= 25 => 0.9,
                $age <= 30 => 0.8,
                $age <= 35 => 0.7,
                $age <= 40 => 0.6,
                $age <= 50 => 0.5,
                $age <= 60 => 0.4,
                $age <= 70 => 0.3,
                $age <= 80 => 0.2,
                $age <= 90 => 0.1,
                default => 0
            };
        }

        return $this->getScoreFromRanges($age, $config['ranges']);
    }

    private function calculateExpectedSalaryScore($salary, $config = null)
    {
        // Return 0 if salary is empty or invalid
        if (empty($salary) || !is_numeric($salary)) {
            return 0;
        }

        // If no config is provided or ranges are empty, use default calculation
        if (empty($config) || empty($config['ranges'])) {
            return match (true) {
                $salary >= 5000001 && $salary <= 8000000 => 1.0,  // Best range
                $salary >= 2000001 && $salary <= 5000000 => 0.8,
                $salary >= 8000001 && $salary <= 10000000 => 0.6,
                $salary >= 0 && $salary <= 2000000 => 0.4,
                $salary >= 10000001 && $salary <= 15000000 => 0.2,
                default => 0
            };
        }

        return $this->getScoreFromRanges($salary, $config['ranges']);
    }

    private function calculateDistanceScore($distance, $config = null)
    {
        // Return 0 if distance is empty or invalid
        if (empty($distance) || !is_numeric($distance)) {
            return 0;
        }

        // Convert distance to float to ensure it's numeric
        $distance = (float)$distance;

        // If no config is provided or ranges are empty, use default calculation
        if (empty($config) || empty($config['ranges'])) {
            return match (true) {
                $distance >= 0 && $distance <= 3 => 1.0,  // Best range (closest)
                $distance >= 3.1 && $distance <= 5 => 0.75,
                $distance >= 5.1 && $distance <= 8 => 0.5,
                $distance >= 10.1 && $distance <= 15 => 0.25,
                default => 0
            };
        }

        return $this->getScoreFromRanges($distance, $config['ranges']);
    }


    private function calculateEducationScore($education, $config = null)
    {
        // Return 0 if education is null or empty
        if (!$education) {
            return 0; // No education data
        }

        // Check if the degree property exists
        if (!isset($education->degree) || empty($education->degree)) {
            return 0; // Missing degree information
        }

        // Equal intervals for 5 levels (0.2 increment each)
        $defaultLevelScores = [
            'SMA' => 0.2,  // 20%
            'SMK' => 0.4,  // 40%
            'D3' => 0.6,   // 60%
            'S1' => 0.8,   // 80%
            'S2' => 1.0    // 100%
        ];

        $levelScore = 0;
        $gradeScore = 0;
        $levelWeight = 0.7; // 70% weight for level
        $gradeWeight = 0.3; // 30% weight for grade

        // Use configuration if available
        if ($config && isset($config['levels']['list']) && !empty($config['levels']['list'])) {
            $levels = collect($config['levels']['list'])
                ->whereIn('name', array_keys($defaultLevelScores))
                ->sortBy('rank')
                ->values()
                ->all();

            $totalLevels = count($levels);

            // Find the education level in configured levels
            foreach ($levels as $level) {
                if ($level['name'] === $education->degree) {
                    $levelScore = 1 - (($level['rank'] - 1) / $totalLevels);
                    break;
            if ($totalLevels > 0) {
                // Find the education level in configured levels
                foreach ($levels as $level) {
                    if ($level['name'] === $education->degree) {
                        $levelScore = 1 - (($level['rank'] - 1) / $totalLevels);
                        break;
                    }
                }
            }

            // If not found in configured levels, use default or zero
            if ($levelScore === 0) {
                $levelScore = $defaultLevelScores[$education->degree] ?? 0;
            }

            // Override weights if configured
            if (isset($config['weights'])) {
                $levelWeight = $config['weights']['level'] / 100;
                $gradeWeight = $config['weights']['grade'] / 100;
            }
        } else {
            // Use default level scores
            $levelScore = $defaultLevelScores[$education->degree] ?? 0;
        }

        // Calculate grade score (same as before)
        if ($education->grade !== null) {
        // Calculate grade score with better validation
        if (isset($education->grade) && $education->grade !== null && is_numeric($education->grade)) {
            if (in_array($education->degree, ['SMK', 'SMA'])) {
                $gradeScore = min(1, max(0, $education->grade / 100));
            } else {
                $gradeScore = min(1, max(0, $education->grade / 4));
            }
        }

        // Combined weighted score
        return ($levelScore * $levelWeight) + ($gradeScore * $gradeWeight);
    }

    private function calculateExperienceDurationScore($applicantId, $config = null)
    // Modified calculateApplicantScoresAHP function to ensure consistent data structure// Fixed calculateApplicantScoresAHP function to preserve actual AHP scores
    private function calculateApplicantScoresAHP($applicants, $weights, $criteriaConfigs)
    {
        $experiences = recruitment_applicant_work_experience::where('applicant_id', $applicantId)->get();
        // Langkah 1: Hitung nilai untuk setiap kriteria pelamar
        $applicantCriteriaMatrix = [];

        if ($experiences->isEmpty()) {
            return 0; // Default low score for no experience
        }
        foreach ($applicants as $applicant) {
            $criteriaValues = [];

        $totalDuration = 0;
        $count = $experiences->count();
            // Hitung nilai untuk setiap kriteria
            foreach ($weights as $criterion => $weight) {
                $rawScore = 0; // Default value

        foreach ($experiences as $exp) {
            $startDate = Carbon::parse($exp->working_start);
            $endDate = $exp->working_end ? Carbon::parse($exp->working_end) : Carbon::now();
            $totalDuration += $startDate->diffInYears($endDate);
                switch ($criterion) {
                    case 'age':
                        $rawScore = $this->calculateAgeScore(
                            $applicant->birth_date,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'expected_salary':
                        $rawScore = $this->calculateExpectedSalaryScore(
                            $applicant->expected_salary ?? 0,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'distance':
                        $rawScore = $this->calculateDistanceScore(
                            $applicant->distance ?? 0,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'education':
                        $education = recruitment_applicant_education::where('applicant_id', $applicant->id)
                            ->orderBy('end_education', 'desc')
                            ->first();
                        $rawScore = $this->calculateEducationScore(
                            $education,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'experience_duration':
                        $rawScore = $this->calculateExperienceDurationScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'training':
                        $rawScore = $this->calculateTrainingScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'language':
                        $rawScore = $this->calculateLanguageScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'organization':
                        $rawScore = $this->calculateOrganizationScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                }

                // Ensure we have a valid numeric value
                $criteriaValues[$criterion] = is_numeric($rawScore) ? (float)$rawScore : 0;
            }

            $applicantCriteriaMatrix[$applicant->id] = $criteriaValues;
        }

        // Default configuration if none provided
        if (empty($config)) {
            $periodRanges = [
                ['min' => 5, 'max' => 8, 'rank' => 1],
                ['min' => 3, 'max' => 5, 'rank' => 2],
                ['min' => 1, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];
        // Langkah 2: Buat matriks perbandingan berpasangan untuk setiap kriteria
        $criteriaWeights = [];

        foreach ($weights as $criterion => $weight) {
            if (count($applicants) < 2) {
                // Jika hanya ada satu pelamar, tidak perlu perbandingan berpasangan
                $criteriaWeights[$criterion] = [$applicants[0]->id => 1];
                continue;
            }

            // Buat matriks perbandingan berpasangan untuk kriteria ini
            $pairwiseMatrix = [];
            $applicantIds = [];

            foreach ($applicants as $applicant) {
                $applicantIds[] = $applicant->id;
                $pairwiseMatrix[$applicant->id] = [];
            }

            // Isi matriks perbandingan berpasangan
            foreach ($applicantIds as $id1) {
                foreach ($applicantIds as $id2) {
                    // Diagonal utama selalu bernilai 1
                    if ($id1 == $id2) {
                        $pairwiseMatrix[$id1][$id2] = 1;
                        continue;
                    }

                    // Jika nilai telah dihitung untuk pasangan sebaliknya, gunakan kebalikannya
                    if (isset($pairwiseMatrix[$id2][$id1])) {
                        $pairwiseMatrix[$id1][$id2] = 1 / $pairwiseMatrix[$id2][$id1];
                        continue;
                    }

                    // Dapatkan nilai kriteria untuk kedua pelamar
                    $value1 = $applicantCriteriaMatrix[$id1][$criterion] ?? 0;
                    $value2 = $applicantCriteriaMatrix[$id2][$criterion] ?? 0;

                    // Handle kasus khusus untuk nilai 0
                    if ($value1 == 0 && $value2 == 0) {
                        $pairwiseMatrix[$id1][$id2] = 1; // Keduanya sama
                    } elseif ($value1 == 0) {
                        $pairwiseMatrix[$id1][$id2] = 1 / 9; // Nilai minimum untuk skala Saaty
                    } elseif ($value2 == 0) {
                        $pairwiseMatrix[$id1][$id2] = 9; // Nilai maksimum untuk skala Saaty
                    } else {
                        // Hitung rasio dan konversi ke skala Saaty (1-9)
                        $ratio = $value1 / $value2;

                        // Konversi rasio ke skala Saaty
                        if ($ratio >= 1) {
                            $pairwiseMatrix[$id1][$id2] = min(9, round($ratio, 2));
                        } else {
                            $pairwiseMatrix[$id1][$id2] = max(1 / 9, round($ratio, 2));
                        }
                    }
                }
            }

            // Langkah 3: Normalisasi matriks perbandingan berpasangan
            $normalizedMatrix = [];
            $columnSums = [];

            // Hitung jumlah setiap kolom
            foreach ($applicantIds as $id2) {
                $columnSums[$id2] = 0;
                foreach ($applicantIds as $id1) {
                    $columnSums[$id2] += $pairwiseMatrix[$id1][$id2];
                }
            }

            // Normalisasi matriks
            foreach ($applicantIds as $id1) {
                $normalizedMatrix[$id1] = [];

                foreach ($applicantIds as $id2) {
                    if ($columnSums[$id2] > 0) {
                        $normalizedMatrix[$id1][$id2] = $pairwiseMatrix[$id1][$id2] / $columnSums[$id2];
                    } else {
                        $normalizedMatrix[$id1][$id2] = 0;
                    }
                }
            }

            $amountRanges = [
                ['min' => 6, 'max' => 7, 'rank' => 1],
                ['min' => 4, 'max' => 5, 'rank' => 2],
                ['min' => 2, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];
            // Langkah 4: Hitung vektor prioritas (bobot lokal) untuk setiap pelamar
            $priorityVector = [];

            $periodScore = $this->getScoreFromRanges($totalDuration, $periodRanges);
            $amountScore = $this->getScoreFromRanges($count, $amountRanges);
            foreach ($applicantIds as $id) {
                $rowSum = 0;
                foreach ($applicantIds as $otherId) {
                    $rowSum += $normalizedMatrix[$id][$otherId];
                }
                $priorityVector[$id] = $rowSum / count($applicantIds);
            }

            return ($periodScore * 0.7) + ($amountScore * 0.3);
            // Menyimpan bobot prioritas untuk kriteria ini
            $criteriaWeights[$criterion] = $priorityVector;
        }

        // Use provided configuration
        $periodScore = isset($config['period']) ? $this->getScoreFromRanges($totalDuration, $config['period']) : 0;
        $amountScore = isset($config['amount']) ? $this->getScoreFromRanges($count, $config['amount']) : 0;
        // Langkah 5: Hitung skor akhir menggunakan bobot kriteria global
        $finalScores = [];

        $periodWeight = isset($config['weights']['period']) ? ($config['weights']['period'] / 100) : 0.7;
        $amountWeight = isset($config['weights']['amount']) ? ($config['weights']['amount'] / 100) : 0.3;
        foreach ($applicants as $applicant) {
            $finalScore = 0;
            $breakdownScores = [];

        return ($periodScore * $periodWeight) + ($amountScore * $amountWeight);
    }
            foreach ($weights as $criterion => $weight) {
                // Get the raw unweighted score (from our calculation functions)
                $rawScore = $applicantCriteriaMatrix[$applicant->id][$criterion] ?? 0;

    private function calculateTrainingScore($applicantId, $config = null)
    {
        $trainings = recruitment_applicant_training::where('applicant_id', $applicantId)->get();
                // Get the normalized score (from AHP comparison)
                $normalizedScore = $criteriaWeights[$criterion][$applicant->id] ?? 0;

        if ($trainings->isEmpty()) {
            return 0;
        }
                // Calculate the weighted score - keep the actual AHP scores
                $weightedScore = $normalizedScore * $weight;

        $count = $trainings->count();
        $totalDuration = 0;
                // Add to final score
                $finalScore += $weightedScore;

        foreach ($trainings as $training) {
            if ($training->start_date && $training->end_date) {
                $startDate = Carbon::parse($training->start_date);
                $endDate = Carbon::parse($training->end_date);
                $totalDuration += $startDate->diffInMonths($endDate);
                // Store the breakdown with CONSISTENT structure
                $breakdownScores[$criterion] = [
                    'raw_score' => $rawScore,
                    'normalized_score' => $normalizedScore,
                    'weighted_score' => $weightedScore,  // This is already the actual AHP weighted score
                    'weight' => $weight
                ];
            }

            $finalScores[] = [
                'applicant' => $applicant,
                'score' => $finalScore,  // This is the actual AHP final score without normalization to 100%
                'breakdown' => $breakdownScores
            ];
        }

        // Convert duration to years for scoring
        $durationInYears = $totalDuration / 12;
        // Sort by score descending - we preserve the actual AHP scores
        return collect($finalScores)->sortByDesc('score')->values();
    }

        // Default configuration if none provided
        if (empty($config)) {
            $periodRanges = [
                ['min' => 5.1, 'max' => 8, 'rank' => 1],
                ['min' => 3.1, 'max' => 5, 'rank' => 2],
                ['min' => 1.1, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
    // Fungsi calculate yang memanggil AHP
    public function calculate(Request $request)
    {
        try {
            // Validate the request - basic validation first
            $validationRules = [
                'demandId' => 'required',
            ];

            $amountRanges = [
                ['min' => 6, 'max' => 7, 'rank' => 1],
                ['min' => 4, 'max' => 5, 'rank' => 2],
                ['min' => 2, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            // Only validate criteria that are included in the request
            $totalPercentage = 0;
            $criteriaKeys = [
                'age',
                'expected_salary',
                'distance',
                'education',
                'experience_duration',
                'organization',
                'language',
                'training'
            ];

            $periodScore = $this->getScoreFromRanges($durationInYears, $periodRanges);
            $amountScore = $this->getScoreFromRanges($count, $amountRanges);
            foreach ($criteriaKeys as $key) {
                if ($request->has($key)) {
                    $validationRules[$key] = 'required|numeric|min:0|max:100';
                    $totalPercentage += (float)$request->$key;
                }
            }

            return ($periodScore * 0.7) + ($amountScore * 0.3);
        }
            $request->validate($validationRules);

        // Use provided configuration
        $periodScore = isset($config['period']) ? $this->getScoreFromRanges($durationInYears, $config['period']) : 0;
        $amountScore = isset($config['amount']) ? $this->getScoreFromRanges($count, $config['amount']) : 0;
            // Validate that percentages sum to 100%
            if (abs($totalPercentage - 100) > 0.01) { // Allow small floating point error
                return response()->json([
                    'success' => false,
                    'message' => 'Total persentase harus 100%'
                ], 422);
            }

        $periodWeight = isset($config['weights']['period']) ? ($config['weights']['period'] / 100) : 0.7;
        $amountWeight = isset($config['weights']['amount']) ? ($config['weights']['amount'] / 100) : 0.3;
            // Get configurations from request
            $criteriaConfigs = $request->criteria_configs ?? [];

        return ($periodScore * $periodWeight) + ($amountScore * $amountWeight);
    }
            // Convert percentages to weights (0-1 scale)
            $weights = [];
            foreach ($criteriaKeys as $key) {
                if ($request->has($key)) {
                    $weights[$key] = $request->$key / 100;
                }
            }

    private function calculateOrganizationScore($applicantId, $config = null)
    {
        $organizations = recruitment_applicant_organization::where('applicant_id', $applicantId)->get();
            // Get applicants data
            $demand = recruitment_demand::findOrFail($request->demandId);
            $applicants = recruitment_applicant::where('recruitment_demand_id', $demand->id)
                ->where('status_applicant', 'Pending')
                ->whereNull('interview_date')->get();

        if ($organizations->isEmpty()) {
            return 0;
        }
            if ($applicants->isEmpty()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Tidak ada pelamar untuk demand ini'
                ], 200);
            }

        $count = $organizations->count();
        $totalDuration = 0;
            // DEBUG: Generate matrix data for debugging
            $debugMatrices = $this->debugMatrices($applicants, $weights, $criteriaConfigs);

        foreach ($organizations as $org) {
            if ($org->start_date) {
                $startDate = Carbon::parse($org->start_date);
                $endDate = $org->end_date ? Carbon::parse($org->end_date) : Carbon::now();
                $totalDuration += $startDate->diffInMonths($endDate);
            }
            // You can either dd() here to see all matrices:
            dd($debugMatrices);

            // Or continue with your normal AHP calculation:
            $rankings = $this->calculateApplicantScoresAHP($applicants, $weights, $criteriaConfigs);

            return response()->json([
                'success' => true,
                'rankings' => $rankings
            ], 200);
        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'success' => false,
                'message' => 'Data yang dikirim tidak valid',
                'errors' => $e->errors()
            ], 422);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error: ' . $e->getMessage()
            ], 500);
        }
    }

        // Convert duration to years for scoring
        $durationInYears = $totalDuration / 12;

        // Default configuration if none provided
        if (empty($config)) {
            $periodRanges = [
                ['min' => 5.1, 'max' => 8, 'rank' => 1],
                ['min' => 3.1, 'max' => 5, 'rank' => 2],
                ['min' => 1.1, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];
    // Add this function to your class to display matrices in a readable format
    private function debugMatrices($applicants, $weights, $criteriaConfigs)
    {
        // Store all matrices for debugging
        $debugData = [
            'criteria_weights' => $weights,
            'criteria_matrix' => [],
            'applicant_criteria_values' => [],
            'pairwise_matrices' => [],
            'normalized_matrices' => [],
            'priority_vectors' => []
        ];

            $amountRanges = [
                ['min' => 6, 'max' => 7, 'rank' => 1],
                ['min' => 4, 'max' => 5, 'rank' => 2],
                ['min' => 2, 'max' => 3, 'rank' => 3],
                ['min' => 0, 'max' => 1, 'rank' => 4]
            ];
        // Step 1: Collect raw applicant criteria values
        foreach ($applicants as $applicant) {
            $criteriaValues = [];

            $periodScore = $this->getScoreFromRanges($durationInYears, $periodRanges);
            $amountScore = $this->getScoreFromRanges($count, $amountRanges);
            foreach ($weights as $criterion => $weight) {
                $rawScore = 0;

            return ($periodScore * 0.4) + ($amountScore * 0.6);
                switch ($criterion) {
                    case 'age':
                        $rawScore = $this->calculateAgeScore(
                            $applicant->birth_date,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'expected_salary':
                        $rawScore = $this->calculateExpectedSalaryScore(
                            $applicant->expected_salary ?? 0,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'distance':
                        $rawScore = $this->calculateDistanceScore(
                            $applicant->distance ?? 0,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'education':
                        $education = recruitment_applicant_education::where('applicant_id', $applicant->id)
                            ->orderBy('end_education', 'desc')
                            ->first();
                        $rawScore = $this->calculateEducationScore(
                            $education,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'experience_duration':
                        $rawScore = $this->calculateExperienceDurationScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'training':
                        $rawScore = $this->calculateTrainingScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'language':
                        $rawScore = $this->calculateLanguageScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                    case 'organization':
                        $rawScore = $this->calculateOrganizationScore(
                            $applicant->id,
                            $criteriaConfigs[$criterion] ?? null
                        );
                        break;
                }

                $rawScore = is_numeric($rawScore) ? (float)$rawScore : 0;
                $criteriaValues[$criterion] = $rawScore;
            }

            $debugData['applicant_criteria_values'][$applicant->id] = [
                'name' => $applicant->name,
                'values' => $criteriaValues
            ];
        }

        // Use provided configuration
        $periodScore = isset($config['period']) ? $this->getScoreFromRanges($durationInYears, $config['period']) : 0;
        $amountScore = isset($config['amount']) ? $this->getScoreFromRanges($count, $config['amount']) : 0;
        // Step 2: Build the criteria pairwise comparison matrix
        // This would be manually entered or calculated elsewhere
        // Here we're just showing a placeholder structure
        $criteria = array_keys($weights);
        foreach ($criteria as $c1) {
            $debugData['criteria_matrix'][$c1] = [];
            foreach ($criteria as $c2) {
                // This should be replaced with your actual criteria matrix values
                if ($c1 === $c2) {
                    $debugData['criteria_matrix'][$c1][$c2] = 1;
                } else {
                    // Placeholder - in your real code this would come from user input or calculation
                    $debugData['criteria_matrix'][$c1][$c2] = 0; // Placeholder
                }
            }
        }

        $periodWeight = isset($config['weights']['period']) ? ($config['weights']['period'] / 100) : 0.4;
        $amountWeight = isset($config['weights']['amount']) ? ($config['weights']['amount'] / 100) : 0.6;
        // Step 3: Calculate pairwise matrices for each criterion
        foreach ($weights as $criterion => $weight) {
            $pairwiseMatrix = [];
            $normalizedMatrix = [];
            $priorityVector = [];

        return ($periodScore * $periodWeight) + ($amountScore * $amountWeight);
    }
            $applicantIds = [];
            foreach ($applicants as $applicant) {
                $applicantIds[] = $applicant->id;
                $pairwiseMatrix[$applicant->id] = [];
            }

            // Fill the pairwise comparison matrix for this criterion
            foreach ($applicantIds as $id1) {
                foreach ($applicantIds as $id2) {
                    if ($id1 == $id2) {
                        $pairwiseMatrix[$id1][$id2] = 1;
                        continue;
                    }

                    if (isset($pairwiseMatrix[$id2][$id1])) {
                        $pairwiseMatrix[$id1][$id2] = 1 / $pairwiseMatrix[$id2][$id1];
                        continue;
                    }

                    $value1 = $debugData['applicant_criteria_values'][$id1]['values'][$criterion] ?? 0;
                    $value2 = $debugData['applicant_criteria_values'][$id2]['values'][$criterion] ?? 0;

                    if ($value1 == 0 && $value2 == 0) {
                        $pairwiseMatrix[$id1][$id2] = 1;
                    } elseif ($value1 == 0) {
                        $pairwiseMatrix[$id1][$id2] = 1 / 9;
                    } elseif ($value2 == 0) {
                        $pairwiseMatrix[$id1][$id2] = 9;
                    } else {
                        $ratio = $value1 / $value2;
                        if ($ratio >= 1) {
                            $pairwiseMatrix[$id1][$id2] = min(9, round($ratio, 2));
                        } else {
                            $pairwiseMatrix[$id1][$id2] = max(1 / 9, round($ratio, 2));
                        }
                    }
                }
            }

    private function calculateLanguageScore($applicantId, $config = null)
    {
        $languages = recruitment_applicant_language::where('applicant_id', $applicantId)->get();
            // Calculate column sums for normalization
            $columnSums = [];
            foreach ($applicantIds as $id2) {
                $columnSums[$id2] = 0;
                foreach ($applicantIds as $id1) {
                    $columnSums[$id2] += $pairwiseMatrix[$id1][$id2];
                }
            }

        if ($languages->isEmpty()) {
            return 0; // Default score for no languages
        }
            // Normalize the matrix
            foreach ($applicantIds as $id1) {
                $normalizedMatrix[$id1] = [];
                foreach ($applicantIds as $id2) {
                    if ($columnSums[$id2] > 0) {
                        $normalizedMatrix[$id1][$id2] = $pairwiseMatrix[$id1][$id2] / $columnSums[$id2];
                    } else {
                        $normalizedMatrix[$id1][$id2] = 0;
                    }
                }
            }

        $verbalWeight = 0.7; // Default 70% weight for verbal skills
        $writtenWeight = 0.3; // Default 30% weight for written skills
            // Calculate priority vector (row averages)
            foreach ($applicantIds as $id) {
                $rowSum = 0;
                foreach ($applicantIds as $otherId) {
                    $rowSum += $normalizedMatrix[$id][$otherId];
                }
                $priorityVector[$id] = $rowSum / count($applicantIds);
            }

        // Override weights if configured
        if ($config && isset($config['weights'])) {
            $verbalWeight = $config['weights']['verbal'] / 100;
            $writtenWeight = $config['weights']['written'] / 100;
            $debugData['pairwise_matrices'][$criterion] = $pairwiseMatrix;
            $debugData['normalized_matrices'][$criterion] = $normalizedMatrix;
            $debugData['priority_vectors'][$criterion] = $priorityVector;
            $debugData['column_sums'][$criterion] = $columnSums;
        }

        $score = 0;
        $count = 0;
        // Step 4: Calculate final scores
        $finalScores = [];
        foreach ($applicants as $applicant) {
            $finalScore = 0;
            $breakdownScores = [];

        foreach ($languages as $language) {
            $verbalScore = ($language->verbal === 'Active') ? 1 : 0.5;
            $writtenScore = ($language->written === 'Active') ? 1 : 0.5;
            foreach ($weights as $criterion => $weight) {
                $priorityValue = $debugData['priority_vectors'][$criterion][$applicant->id] ?? 0;
                $weightedScore = $priorityValue * $weight;
                $finalScore += $weightedScore;

                $breakdownScores[$criterion] = [
                    'raw_score' => $debugData['applicant_criteria_values'][$applicant->id]['values'][$criterion],
                    'normalized_score' => $priorityValue,
                    'weighted_score' => $weightedScore,
                    'weight' => $weight
                ];
            }

            // Weighted score for this language
            $languageScore = ($verbalScore * $verbalWeight) + ($writtenScore * $writtenWeight);
            $score += $languageScore;
            $count++;
            $finalScores[$applicant->id] = [
                'name' => $applicant->name,
                'score' => $finalScore,
                'breakdown' => $breakdownScores
            ];
        }

        // Return average language score
        return $count > 0 ? min(1.0, $score / $count) : 0.2;
        $debugData['final_scores'] = $finalScores;

        // Output in debug format
        return $debugData;
    }